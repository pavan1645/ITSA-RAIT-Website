Simple circle:
#include<graphics.h>
void main()
{
int gd=DETECT, gm;
initgraph(&gd, &gm,NULL);
setbkcolor(1);
setcolor(12);
circle(400,300,100);
setcolor(4);
floodfill(400,300,12);
setcolor(14);
line(50,50,100,50);
line(100,50,100,200);
line(100,200,50,200);
line(50,200,50,50);
setcolor(2);
floodfill(70,100,14);
delay(5000);
getch();
closegraph();
}

OpenGL:
Code:
#ifdef __APPLE_CC__
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#endif
// Clears the current window and draws a triangle.
void display() {
  // Set every pixel in the frame buffer to the current clear color.
  glClear(GL_COLOR_BUFFER_BIT);
  // Drawing is done by specifying a sequence of vertices.  The way these
  // vertices are connected (or not connected) depends on the argument to
  // glBegin.  GL_POLYGON constructs a filled polygon.
  glBegin(GL_POLYGON);
    glColor3f(1, 0, 0); glVertex3f(-0.6, -0.75, 0.5);
    glColor3f(0, 1, 0); glVertex3f(0.6, -0.75, 0);
    glColor3f(0, 0, 1); glVertex3f(0, 0.75, 0);
  glEnd();
  // Flush drawing command buffer to make drawing happen as soon as possible.
  glFlush();
}
// Initializes GLUT, the display mode, and main window; registers callbacks;
// enters the main event loop.
int main(int argc, char** argv) {
  // Use a single buffered window in RGB mode (as opposed to a double-buffered
  // window or color-index mode).
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
  // Position window at (80,80)-(480,380) and give it a title.
  glutInitWindowPosition(80, 80);
  glutInitWindowSize(400, 300);
  glutCreateWindow("A Simple Triangle");
  // Tell GLUT that whenever the main window needs to be repainted that it
  // should call the function display().
  glutDisplayFunc(display);
  // Tell GLUT to start reading and processing events.  This function
  // never returns; the program only exits when the user closes the main
  // window or kills the process.
  glutMainLoop();
}

DDA:
#include <graphics.h>
#include <stdio.h>
#include <math.h>

int main( )
{
    float x,y,x1,y1,x2,y2,dx,dy,pixel;
    int i,gd,gm;

    printf("Enter the value of x1 : ");
    scanf("%f",&x1);
    printf("Enter the value of y1 : ");
    scanf("%f",&y1);
    printf("Enter the value of x2 : ");
    scanf("%f",&x2);
    printf("Enter the value of y1 : ");
    scanf("%f",&y2);

    detectgraph(&gd,&gm);
    initgraph(&gd,&gm,"");

    dx=abs(x2-x1);
    dy=abs(y2-y1);

    if(dx>=dy)
    pixel=dx;
    else
    pixel=dy;

    dx=dx/pixel;
    dy=dy/pixel;

    x=x1;
    y=y1;

    i=1;
    while(i<=pixel)
    {
          putpixel(x,y,1);
          x=x+dx;
          y=y+dy;
          i=i+1;
          delay(100);
    }
    getch();
    closegraph();
}

Bresenham:
#include <stdio.h>
#include <graphics.h>
void lineBres(int, int, int, int);
void main()
{
int x1, y1, xn, yn;
int gd = DETECT, gm;
printf("Enter starting coordinates of line: ");
scanf("%d %d", &x1, &y1);
printf("Enter ending coordinates of line: ");
scanf("%d %d", &xn, &yn);
initgraph(&gd, &gm, "");
lineBres(x1, y1, xn, yn);
getch();
}
void lineBres(int x1, int y1, int xn, int yn)
{
int dx = xn-x1,
dy = yn-y1;
int di = 2 * dy-dx;
int ds = 2 * dy, dt = 2 * (dy-dx);
putpixel(x1, y1, RED);
while (x1 < xn)
{
x1++;
if (di < 0)
di = di + ds;
else
{
y1++;
di = di + dt;
}
putpixel(x1, y1, YELLOW);
delay(20);
}
}
